--[[
MIT License
Copyright (c) 2025 sigma-axis

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

https://mit-license.org/
]]
@パス図形σ
--information:パス図形σ@Path_S v1.00-rc8 (for beta20) by σ軸
--label:Path_S\図形
--value@num_points:頂点数,4
--select@path_type:線タイプ=3,折れ線=0,補間移動=1,2次ベジェ曲線=2,3次ベジェ曲線=3
--value@points:点リスト,{0,-100,55.23,-100,100,-55.23,100,0,100,55.23,55.23,100,0,100,-55.23,100,-100,55.23,-100,0,-100,-55.23,-55.23,-100}
--track@precision:曲線精度,1,128,8,1
--track@antialias:ぼかし幅,0,1000,1,0.01
--color@color_line:ライン色,0x808080
--track@alpha_line:ライン透明度,0,100,0,0.01
--track@line:ライン幅,0,1000,5,0.01
--check@loop:ループ,true
--track@start_pos:開始位置,-200,200,0,0.001
--track@end_pos:終了位置,-200,200,100,0.001
--select@end_shape:端の形状=0,円=0,四角=1
--value@dash_pat:破線パターン,{100,0}
--check@dash_adj:破線周期補正,true
--track@dash_pos:破線位置,-4000,4000,0,0.01
--color@color_fill:塗り色,0xffffff
--track@alpha_fill:塗り透明度,0,100,0,0.01
--track@inflation:塗り追加幅,0,1000,0,0.01
--select@mode_fill:塗り範囲=0,内側=0,奇偶=1
--track@rand_period:ランダム周期,4,1024,32,0.001
--track@rand_amplify:ランダム振幅,0,1024,0,0.01
--check@rand_fix_end:ランダム固定端,true
--track@rand_seed:ランダムシード,-65536,65535,10000,1
--value@PI:PI,{}
local path_s = require "Path_S";
local obj, math, tonumber, type = obj, math, tonumber, type;

-- set anchors.
if obj.getoption("gui") then
	num_points = math.max(math.floor(0.5 + (tonumber(num_points) or 4)), 2);
	path_type = math.min(math.max(math.floor(0.5 + path_type), 0), 3);
	path_s.anchor("points", path_type, points, num_points - (loop and 0 or 1), loop);
end

-- take parameters. (they don't affect to anchors.)
--[[
	PI = {
		num_points:		number?,
		path_type:		string?,
		points:			table?,
		precision:		number?,
		antialias:		number?,
		color_line:		number?,
		alpha_line:		number?,
		line:			number?,
		loop:			boolean|number|nil,
		start_pos:		number?,
		end_pos:		number?,
		end_shape:		string?,
		dash_pat:		table?,
		dash_adj:		boolean|number|nil,
		dash_pos:		number?,
		color_fill:		number?,
		alpha_fill:		number?,
		inflation:		number?,
		mode_fill:		string?,
		rand_period:	number?,
		rand_amplify:	number?,
		rand_fix_end:	boolean|number|nil,
		rand_seed:		number?,
	}
]]
local function as_bool(t, v)
	if type(t) == "boolean" then return t;
	elseif type(t) == "number" then return t ~= 0;
	else return v end
end
num_points = tonumber(PI.num_points) or num_points;
if type(PI.path_type) == "string" then
	local name2num = {
		["折れ線"] = 0, ["補間移動"] = 1, ["2次ベジェ曲線"] = 2, ["3次ベジェ曲線"] = 3,
	};
	path_type = name2num[PI.path_type] or path_type;
end
if type(PI.points) == "table" then points = PI.points end
precision = tonumber(PI.precision) or precision;
antialias = tonumber(PI.antialias) or antialias;
color_line = tonumber(PI.color_line) or color_line;
alpha_line = tonumber(PI.alpha_line) or alpha_line;
line = tonumber(PI.line) or line;
loop = as_bool(PI.loop, loop);
start_pos = tonumber(PI.start_pos) or start_pos;
end_pos = tonumber(PI.end_pos) or end_pos;
if type(PI.end_shape) == "string" then
	local name2num = {
		["円"] = 0, ["四角"] = 1,
	};
	end_shape = name2num[PI.end_shape] or end_shape;
end
if type(PI.dash_pat) == "table" then dash_pat = PI.dash_pat end
dash_adj = as_bool(PI.dash_adj, dash_adj);
dash_pos = tonumber(PI.dash_pos) or dash_pos;
color_fill = tonumber(PI.color_fill) or color_fill;
alpha_fill = tonumber(PI.alpha_fill) or alpha_fill;
inflation = tonumber(PI.inflation) or inflation;
if type(PI.mode_fill) == "string" then
	local name2num = {
		["内側"] = 0, ["奇偶"] = 1,
	};
	mode_fill = name2num[PI.mode_fill] or mode_fill;
end
rand_period = tonumber(PI.rand_period) or rand_period;
rand_amplify = tonumber(PI.rand_amplify) or rand_amplify;
rand_fix_end = as_bool(PI.rand_fix_end, rand_fix_end);
rand_seed = tonumber(PI.rand_seed) or rand_seed;

-- normalize parameters.
num_points = math.max(math.floor(0.5 + num_points), 2);
path_type = math.min(math.max(math.floor(0.5 + path_type), 0), 3);
precision = math.max(precision, 1);
antialias = math.max(antialias, 0);
color_line = color_line % 2 ^ 24;
alpha_line = math.min(math.max(1 - alpha_line / 100, 0), 1);
line = math.max(line, 0);
end_shape = math.min(math.max(math.floor(0.5 + end_shape), 0), 1);
color_fill = color_fill % 2 ^ 24;
alpha_fill = math.min(math.max(1 - alpha_fill / 100, 0), 1);
inflation = math.max(inflation, 0);
mode_fill = math.min(math.max(math.floor(0.5 + mode_fill), 0), 1);
rand_period = math.max(rand_period, 4);
rand_amplify = math.max(rand_amplify, 0);
rand_seed = math.min(math.max(math.floor(0.5 + rand_seed), -2 ^ 16), 2 ^ 16 - 1);

-- parse/measure the path.
points, num_points = path_s.poll(path_type, points, num_points - (loop and 0 or 1), loop, precision);
if rand_amplify > 0 then
	-- randomize the path.
	points, num_points = path_s.randomize(points, num_points, rand_period, rand_amplify,
		loop and 2 or rand_fix_end and 1 or 0, rand_seed);
end
local L, R, T, B, len = path_s.measure(points, num_points);
local th = math.max(line * (end_shape == 1 and 0.5 ^ 0.5 or 0.5), inflation) + antialias;
L, T = math.floor(L - th), math.floor(T - th);
R, B = math.max(math.ceil(R + th), L + 1), math.max(math.ceil(B + th), T + 1);

-- calculate the end points from the calculated length.
local endpt_buff = nil;
if end_shape == 1 and line > 0 and alpha_line > 0 then
	endpt_buff = { 0.0, 0.0, 0.0, 0.0; 0.0, 0.0, 0.0, 0.0 };

	local st, ed = start_pos / 100, end_pos / 100;
	if loop then st, ed = st % 1, ed % 1
	else st, ed = math.min(math.max(st, 0), 1), math.min(math.max(ed, 0), 1) end

	local i, j, l = path_s.find_index(-st, points, num_points);
	endpt_buff[1], endpt_buff[2], endpt_buff[3], endpt_buff[4] =
		(1 - j) * points[2 * i - 1] + j * points[2 * i + 1] - L,
		(1 - j) * points[2 * i - 0] + j * points[2 * i + 2] - T,
		points[2 * i + 1] - points[2 * i - 1],
		points[2 * i + 2] - points[2 * i - 0];
	i, j = path_s.find_index(-ed, l);
	endpt_buff[5], endpt_buff[6], endpt_buff[7], endpt_buff[8] =
		(1 - j) * points[2 * i - 1] + j * points[2 * i + 1] - L,
		(1 - j) * points[2 * i - 0] + j * points[2 * i + 2] - T,
		points[2 * i + 1] - points[2 * i - 1],
		points[2 * i + 2] - points[2 * i - 0];
end

-- prepare the canvas.
obj.setoption("drawtarget", "tempbuffer", R - L, B - T);
obj.copybuffer("object", "tempbuffer");
obj.cx, obj.cy = -(L + R) / 2, -(T + B) / 2;

-- draw the figures.
if (line > 0 and alpha_line > 0) or alpha_fill > 0 then
	local cache_name, num_segments = "cache:path_s/coords", num_points;
	if not loop and alpha_fill > 0 then
		-- close the loop for drawing the filling part.
		num_points = num_points + 1;
		points[2 * num_points - 1], points[2 * num_points] = points[1], points[2];
	end
	path_s.send(points, num_points, -L, -T, cache_name);

	-- draw the shape of the filling part.
	if alpha_fill > 0 then
		obj.clearbuffer("object", color_fill);
		obj.effect("パスマスクσ@Path_S", "点リスト", "", "PI",
			([[num_points=%d,antialias=%s,inflation=%s,mode_fill=%q,pt_buff=%q]]):format(
				num_points, antialias, inflation, ({ "内側", "奇偶" })[mode_fill + 1], cache_name));
		obj.draw(0, 0, 0, 1, alpha_fill);
	end

	-- then the outline part.
	if line > 0 and alpha_line > 0 then
		obj.clearbuffer("object", color_line);
		obj.effect("パスマスク(ライン)σ@Path_S", "点リスト", "", "PI",
			([[line=%s,num_points=%d,antialias=%s,loop=%s,start_pos=%s,end_pos=%s,end_shape=%q,dash_pat={%s},dash_adj=%s,dash_pos=%s,pt_buff=%q,len_buff=%s%s]]):format(
				line, num_segments, antialias,
				tostring(loop), start_pos, end_pos, ({ "円", "四角" })[end_shape + 1],
				("%s,"):rep(#dash_pat):format(unpack(dash_pat)), tostring(dash_adj), dash_pos,
				cache_name, len, endpt_buff and (",endpt_buff={%s,%s,%s,%s;%s,%s,%s,%s}"):format(unpack(endpt_buff)) or ""));
		obj.draw(0, 0, 0, 1, alpha_line);
	end
	obj.copybuffer("object", "tempbuffer");
end

@ラインσ
--information:ラインσ@Path_S v1.00-rc8 (for beta20) by σ軸
--label:Path_S\図形
--track0:終点X,-4000,4000,256,0.01
--track1:終点Y,-4000,4000,0,0.01
--color@color:色,0xffffff
--track@line:ライン幅,0,1000,5,0.01
--select@end_shape:端の形状=0,円=0,四角=1
--select@line_shape:形状=1,直線=0,正弦波=1,三角波=2,矩形波=3,のこぎり波=4
--track@antialias:ぼかし幅,0,1000,1,0.01
--track@line_period:周期,4,1024,64,0.001
--track@line_phase:周期位置,-4000,4000,0,0.01
--track@line_amplify:振幅,0,1024,32,0.01
--value@dash_pat:破線パターン,{100,0}
--track@dash_pos:破線位置,-4000,4000,0,0.01
--track@rand_period:ランダム周期,4,1024,32,0.01
--track@rand_amplify:ランダム振幅,0,1024,0,0.001
--check@rand_fix_end:ランダム固定端,true
--track@rand_seed:ランダムシード,-65536,65535,10000,1
--value@PI:PI,{}
local path_s = require "Path_S";
local obj, math, tonumber, type = obj, math, tonumber, type;

-- set anchors.
if obj.getoption("gui") then
	obj.setanchor("track", 0, "star", "line");
end

-- take parameters.
--[==[
	PI = {
		X, Y:			number?,
		color:			number?,
		line:			number?,
		end_shape:		string?,
		line_shape:		string?,
		antialias:		number?,
		line_period:	number?,
		line_phase:		number?,
		line_amplify:	number?,
		dash_pat:		table?,
		dash_pos:		number?,
		rand_period:	number?,
		rand_amplify:	number?,
		rand_fix_end:	boolean|number|nil,
		rand_seed:		number?,
	}
]==]
local function as_bool(t, v)
	if type(t) == "boolean" then return t;
	elseif type(t) == "number" then return t ~= 0;
	else return v end
end
local X, Y =
	tonumber(PI.X) or obj.track0,
	tonumber(PI.Y) or obj.track1;
color = tonumber(PI.color) or color;
line = tonumber(PI.line) or line;
if type(PI.end_shape) == "string" then
	local name2num = {
		["円"] = 0, ["四角"] = 1,
	};
	end_shape = name2num[PI.end_shape] or end_shape;
end
if type(PI.line_shape) == "string" then
	local name2num = {
		["直線"] = 0,["正弦波"] = 1,["三角波"] = 2,["矩形波"] = 3, ["のこぎり波"] = 4,
	};
	line_shape = name2num[PI.line_shape] or line_shape;
end
antialias = tonumber(PI.antialias) or antialias;
line_period = tonumber(PI.line_period) or line_period;
line_phase = tonumber(PI.line_phase) or line_phase;
line_amplify = tonumber(PI.line_amplify) or line_amplify;
dash_pat = type(PI.dash_pat) == "table" and PI.dash_pat or dash_pat;
dash_pos = tonumber(PI.dash_pos) or dash_pos;
rand_period = tonumber(PI.rand_period) or rand_period;
rand_amplify = tonumber(PI.rand_amplify) or rand_amplify;
rand_fix_end = as_bool(PI.rand_fix_end, rand_fix_end);
rand_seed = tonumber(PI.rand_seed) or rand_seed;

-- normalize parameters.
color = math.floor(0.5 + color) % 2 ^ 24;
line = math.max(line, 0);
end_shape = math.min(math.max(math.floor(0.5 + end_shape), 0), 1);
line_shape = math.min(math.max(math.floor(0.5 + line_shape), 0), 4);
antialias = math.max(antialias, 0);
line_period = math.max(line_period, 4);
line_amplify = math.max(line_amplify, 0);
rand_period = math.max(rand_period, 4);
rand_amplify = math.max(rand_amplify, 0);
rand_seed = math.min(math.max(math.floor(0.5 + rand_seed), -2 ^ 16), 2 ^ 16 - 1);

-- further calculations.
local length = (X ^ 2 + Y ^ 2) ^ 0.5;
if length <= 0 then
	-- no image.
	obj.setoption("draw_state", true);
	return;
end

-- make the table of the points for the curve.
local n_pts, pts
if line_shape == 0 then
	-- straight line.
	n_pts, pts = 2, { 0, 0, length, 0 };
elseif line_shape == 1 then
	-- sine wave.
	local dp, p = math.min(2 ^ -math.ceil(math.log((line_period + line_amplify) / 8, 2)), 1 / 16),
		((-line_phase) / line_period) % 1;
	n_pts, pts = 1, { 0, line_amplify * math.sin(2 * math.pi * p) };
	local x do
		local p1 = (math.floor(p / dp) + 1) * dp;
		x = (p1 - p) * line_period;
		p = p1 % 1;
	end
	while x < length do
		n_pts = n_pts + 1;
		pts[2 * n_pts - 1], pts[2 * n_pts] =
			x, line_amplify * math.sin(2 * math.pi * p);
		x, p = x + dp * line_period, (p + dp) % 1;
	end
	p = (p - (x - length) / line_period) % 1;
	n_pts = n_pts + 1;
	pts[2 * n_pts - 1], pts[2 * n_pts] =
		length, line_amplify * math.sin(2 * math.pi * p);
elseif line_shape == 2 then
	-- triangular wave.
	local p = (((-line_phase) / line_period) - 0.25) % 1;
	n_pts, pts = 1, { 0, line_amplify * (4 * math.abs(p - 0.5) - 1) };
	local x do
		local p1 = (math.floor(2 * p) + 1) / 2;
		x = (p1 - p) * line_period;
		p = p1 % 1;
	end
	while x < length do
		n_pts = n_pts + 1;
		pts[2 * n_pts - 1], pts[2 * n_pts] =
			x, line_amplify * (p > 0 and -1 or 1);
		x, p = x + 0.5 * line_period, (p + 0.5) % 1;
	end
	p = (p - (x - length) / line_period) % 1;
	n_pts = n_pts + 1;
	pts[2 * n_pts - 1], pts[2 * n_pts] =
		length, line_amplify * (4 * math.abs(p - 0.5) - 1);
elseif line_shape == 3 then
	-- square wave.
	local p = ((-line_phase) / line_period) % 1;
	n_pts, pts = 1, { 0, line_amplify * (p < 0.5 and -1 or 1) };
	local x do
		local p1 = (math.floor(2 * p) + 1) / 2;
		x = (p1 - p) * line_period;
		p = p1 % 1;
	end
	while x < length do
		n_pts = n_pts + 2;
		pts[2 * n_pts - 3], pts[2 * n_pts - 2] =
			x, line_amplify * (p > 0 and -1 or 1);
		pts[2 * n_pts - 1], pts[2 * n_pts] = pts[2 * n_pts - 3], -pts[2 * n_pts - 2];
		x, p = x + 0.5 * line_period, (p + 0.5) % 1;
	end
	p = (p - (x - length) / line_period) % 1;
	n_pts = n_pts + 1;
	pts[2 * n_pts - 1], pts[2 * n_pts] =
		length, line_amplify * (p <= 0.5 and -1 or 1);
else -- line_shape == 4
	-- saw wave.
	local p = ((-line_phase) / line_period) % 1;
	n_pts, pts = 1, { 0, line_amplify * (2 * p - 1) };
	local x do
		local p1 = (math.floor(p) + 1);
		x = (p1 - p) * line_period;
		p = 0;
	end
	while x < length do
		n_pts = n_pts + 2;
		pts[2 * n_pts - 3], pts[2 * n_pts - 2] =
			x, line_amplify;
		pts[2 * n_pts - 1], pts[2 * n_pts] = pts[2 * n_pts - 3], -pts[2 * n_pts - 2];
		x = x + line_period;
	end
	p = 1 - (((x - length) / line_period) % 1);
	n_pts = n_pts + 1;
	pts[2 * n_pts - 1], pts[2 * n_pts] =
		length, line_amplify * (2 * p - 1);
end

-- randomize the line.
if rand_amplify > 0 then
	pts, n_pts = path_s.randomize(pts, n_pts, rand_period, rand_amplify,
		rand_fix_end and 1 or 0, rand_seed);
end

-- measure and move the path.
path_s.transform(pts, n_pts, 1, math.atan2(Y, X));
local L, R, T, B, len = path_s.measure(pts, n_pts);
local th = math.ceil(line * (end_shape == 1 and 0.5 ^ 0.5 or 0.5) + antialias);

-- record the end points.
local endpt_buff = nil;
if end_shape == 1 then
	endpt_buff = {
		pts[1] - L + th, pts[2] - T + th, pts[3] - pts[1], pts[4] - pts[2];
		pts[2 * n_pts - 1] - L + th, pts[2 * n_pts] - T + th,
		pts[2 * n_pts - 1] - pts[2 * n_pts - 3], pts[2 * n_pts] - pts[2 * n_pts - 2];
	};
end

-- prepare the canvas.
local w, h = math.ceil(R - L) + 2 * th, math.ceil(B - T) + 2 * th;
obj.setoption("drawtarget", "tempbuffer", w, h);
obj.copybuffer("object", "tempbuffer");
obj.clearbuffer("object", color);

-- draw the line.
path_s.send(pts, n_pts, -L + th, -T + th);
obj.effect("パスマスク(ライン)σ@Path_S", "点リスト", "", "PI",
	([[line=%s,num_points=%d,antialias=%s,end_shape=%q,dash_pat={%s},dash_pos=%s,pt_buff=%q,len_buff=%s%s]]):format(
		line, n_pts, antialias, ({ "円", "四角" })[end_shape + 1],
		("%s,"):rep(#dash_pat):format(unpack(dash_pat)), dash_pos,
		"tempbuffer", len, endpt_buff and (",endpt_buff={%s,%s,%s,%s;%s,%s,%s,%s}"):format(unpack(endpt_buff)) or ""));

-- adjust the position.
obj.cx, obj.cy = -w / 2 - L + th, -h / 2 - T + th;

@スパイラルσ
--information:スパイラルσ@Path_S v1.00-rc8 (for beta20) by σ軸
--label:Path_S\図形
--track@slope:傾き,-200,200,10,0.001
--color@color:色,0xffffff
--track@line:ライン幅,0,1000,5,0.01
--select@end_shape:端の形状=0,円=0,四角=1
--select@line_shape:形状=1,アルキメデス螺旋=0,対数螺旋=1
--track@precision:曲線精度,1,128,8,1
--track@antialias:ぼかし幅,0,1000,1,0.01
--track@start_radius:開始半径,0,2000,0,0.01
--track@end_radius:終了半径,0,2000,256,0.01
--track@rotate:回転,-720,720,0,0.01
--track0:ずれX,-4000,4000,0,0.01
--track1:ずれY,-4000,4000,0,0.01
--value@dash_pat:破線パターン,{100,0}
--track@dash_pos:破線位置,-4000,4000,0,0.01
--track@rand_period:ランダム周期,4,1024,32,0.01
--track@rand_amplify:ランダム振幅,0,1024,0,0.001
--check@rand_fix_end:ランダム固定端,false
--track@rand_seed:ランダムシード,-65536,65535,10000,1
--value@PI:PI,{}
local path_s = require "Path_S";
local obj, math, tonumber, type = obj, math, tonumber, type;

-- set anchors.
if obj.getoption("gui") then
	obj.setanchor("track", 0, "star", "line");
end

-- take parameters.
--[==[
	PI = {
		slope:			number?,
		color:			number?,
		line:			number?,
		end_shape:		string?,
		line_shape:		string?,
		precision:		number?,
		antialias:		number?,
		start_radius:	number?,
		end_radius:		number?,
		rotate:			number?,
		X, Y:			number?,
		dash_pat:		table?,
		dash_pos:		number?,
		rand_period:	number?,
		rand_amplify:	number?,
		rand_fix_end:	boolean|number|nil,
		rand_seed:		number?,
	}
]==]
local function as_bool(t, v)
	if type(t) == "boolean" then return t;
	elseif type(t) == "number" then return t ~= 0;
	else return v end
end
slope = tonumber(PI.slope) or slope;
color = tonumber(PI.color) or color;
line = tonumber(PI.line) or line;
if type(PI.end_shape) == "string" then
	local name2num = {
		["円"] = 0, ["四角"] = 1,
	};
	end_shape = name2num[PI.end_shape] or end_shape;
end
if type(PI.line_shape) == "string" then
	local name2num = {
		["アルキメデス螺旋"] = 0, ["対数螺旋"] = 1,
	};
	line_shape = name2num[PI.line_shape] or line_shape;
end
precision = tonumber(PI.precision) or precision;
antialias = tonumber(PI.antialias) or antialias;
start_radius = tonumber(PI.start_radius) or start_radius;
end_radius = tonumber(PI.end_radius) or end_radius;
rotate = tonumber(PI.rotate) or rotate;
local X, Y = tonumber(PI.X) or obj.track0, tonumber(PI.Y) or obj.track1;
dash_pat = type(PI.dash_pat) == "table" and PI.dash_pat or dash_pat;
dash_pos = tonumber(PI.dash_pos) or dash_pos;
rand_period = tonumber(PI.rand_period) or rand_period;
rand_amplify = tonumber(PI.rand_amplify) or rand_amplify;
rand_fix_end = as_bool(PI.rand_fix_end, rand_fix_end);
rand_seed = tonumber(PI.rand_seed) or rand_seed;

-- normalize parameters.
color = math.floor(0.5 + color) % 2 ^ 24;
line = math.max(line, 0);
end_shape = math.min(math.max(math.floor(0.5 + end_shape), 0), 1);
line_shape = math.min(math.max(math.floor(0.5 + line_shape), 0), 1);
precision = math.max(precision, 1);
antialias = math.max(antialias, 0);
start_radius = math.max(start_radius, 0);
end_radius = math.max(end_radius, 0);
rotate = math.pi / 180 * (rotate % 360);
X, Y = X / 256, Y / 256;
rand_period = math.max(rand_period, 4);
rand_amplify = math.max(rand_amplify, 0);
rand_seed = math.min(math.max(math.floor(0.5 + rand_seed), -2 ^ 16), 2 ^ 16 - 1);

-- prepare the function for the curve, which maps from a radius to a pair (angle, diff_radius).
local curve_func if line_shape == 0 then
	-- archimedean spiral.
	local s, d = (2 * math.pi / 1024) * slope, precision;
	local a0 = 128 * s;
	function curve_func(r)
		local a = s * r;
		return a - a0, (1 + a ^ 2) ^ -0.5 * d;
	end
else -- line_shape == 1.
	-- logarithmic spiral.
	local s, d, log = slope, (1 + slope ^ 2) ^ -0.5 * precision, math.log;
	function curve_func(r)
		return r > 0 and s * log(r / 128) or 0, d;
	end
end

-- make the array of the points for the curve.
local pts, n_pts = {}, 0 do
	-- poll points from inner to outer.
	local r, R = math.min(start_radius, end_radius), math.max(start_radius, end_radius);
	while true do
		local a, dr = curve_func(r);
		n_pts = n_pts + 1;
		pts[2 * n_pts - 1], pts[2 * n_pts] =
			r * (X + math.sin(a + rotate)),
			r * (Y - math.cos(a + rotate));
		if r >= R then break end
		r = math.min(r + dr, R);
	end

	-- reverse the array if necessary.
	if start_radius > end_radius then
		for i = 1, math.floor(n_pts / 2) do
			local j = n_pts + 1 - i;
			pts[2 * i - 1], pts[2 * j - 1] = pts[2 * j - 1], pts[2 * i - 1];
			pts[2 * i], pts[2 * j] = pts[2 * j], pts[2 * i];
		end
	end
end

-- randomize the path.
if rand_amplify > 0 then
	pts, n_pts = path_s.randomize(pts, n_pts, rand_period, rand_amplify,
		rand_fix_end and 1 or 0, rand_seed);
end

-- measure and move the path.
local L, R, T, B, len = path_s.measure(pts, n_pts);
local th = math.ceil(line * (end_shape == 1 and 0.5 ^ 0.5 or 0.5) + antialias);

-- record the end points.
local endpt_buff = nil;
if end_shape == 1 then
	endpt_buff = {
		pts[1] - L + th, pts[2] - T + th, pts[3] - pts[1], pts[4] - pts[2];
		pts[2 * n_pts - 1] - L + th, pts[2 * n_pts] - T + th,
		pts[2 * n_pts - 1] - pts[2 * n_pts - 3], pts[2 * n_pts] - pts[2 * n_pts - 2];
	};
end

-- prepare the canvas.
local w, h = math.ceil(R - L) + 2 * th, math.ceil(B - T) + 2 * th;
obj.setoption("drawtarget", "tempbuffer", w, h);
obj.copybuffer("object", "tempbuffer");
obj.clearbuffer("object", color);

-- draw the path.
path_s.send(pts, n_pts, -L + th, -T + th);
obj.effect("パスマスク(ライン)σ@Path_S", "点リスト", "", "PI",
	([[line=%s,num_points=%d,antialias=%s,end_shape=%q,dash_pat={%s},dash_pos=%s,pt_buff=%q,len_buff=%s%s]]):format(
		line, n_pts, antialias, ({ "円", "四角" })[end_shape + 1],
		("%s,"):rep(#dash_pat):format(unpack(dash_pat)), dash_pos,
		"tempbuffer", len, endpt_buff and (",endpt_buff={%s,%s,%s,%s;%s,%s,%s,%s}"):format(unpack(endpt_buff)) or ""));

-- adjust the position.
obj.cx, obj.cy = -w / 2 - L + th, -h / 2 - T + th;

@アローσ
--information:アローσ@Path_S v1.00-rc8 (for beta20) by σ軸
--label:Path_S\図形
--color@color:色,0xffffff
--track@line:ライン幅,0,1000,5,0.01
--select@head_type:矢じり配置=1,なし=0,終点=1,両方=2,双方向=3
--figure@head_fig:矢じり図形,三角形
--track@head_size:矢じりサイズ,0,1024,32,0.01
--track@head_width:矢じり幅,0,800,100,0.001
--track@head_center:矢じり中心,-100,100,-50,0.001
--track@head_rot:矢じり角度,-720,720,0,0.01
--track@head_pos:矢じり位置,-100,100,0,0.001
--value@num_points:頂点数,4
--select@path_type:線タイプ=3,折れ線=0,補間移動=1,2次ベジェ曲線=2,3次ベジェ曲線=3
--value@points:点リスト,{-100.00,50.00,-75.00,0.00,-50.00,-50.00,-25.00,-50.00,0.00,-50.00,0.00,50.00,25.00,50.00,50.00,50.00,75.00,0.00,100.00,-50.00}
--track@precision:曲線精度,1,128,8,1
--track@antialias:ぼかし幅,0,1000,1,0.01
--track@start_pos:開始位置,0,100,0,0.001
--track@end_pos:終了位置,0,100,100,0.001
--select@end_shape:端の形状=0,円=0,四角=1
--value@dash_pat:破線パターン,{100,0}
--track@dash_pos:破線位置,-4000,4000,0,0.01
--track@rand_period:ランダム周期,4,1024,32,0.001
--track@rand_amplify:ランダム振幅,0,1024,0,0.01
--check@rand_fix_end:ランダム固定端,true
--track@rand_seed:ランダムシード,-65536,65535,10000,1
--value@PI:PI,{}
local path_s = require "Path_S";
local obj, math, tonumber, type = obj, math, tonumber, type;

-- set anchors.
if obj.getoption("gui") then
	num_points = math.max(math.floor(0.5 + (tonumber(num_points) or 4)), 2);
	path_type = math.min(math.max(math.floor(0.5 + path_type), 0), 3);
	path_s.anchor("points", path_type, points, num_points - 1, false);
end

-- take parameters. (they don't affect to anchors.)
--[==[
	PI = {
		color:			number?,
		line:			number?,
		head_type:		string?,
		head_fig:		string?,
		head_size:		number?,
		head_width:		number?,
		head_center:	number?,
		head_rot:		number?,
		head_pos:		number?,
		num_points:		number?,
		path_type:		string?,
		points:			table?,
		precision:		number?,
		antialias:		number?,
		start_pos:		number?,
		end_pos:		number?,
		end_shape:		string?,
		dash_pat:		table?,
		dash_pos:		number?,
		rand_period:	number?,
		rand_amplify:	number?,
		rand_fix_end:	boolean|number|nil,
		rand_seed:		number?,
	}
]==]
local function as_bool(t, v)
	if type(t) == "boolean" then return t;
	elseif type(t) == "number" then return t ~= 0;
	else return v end
end
color = tonumber(PI.color) or color;
line = tonumber(PI.line) or line;
if type(PI.head_type) == "string" then
	local name2num = {
		["なし"] = 0, ["終点"] = 1, ["両方"] = 2, ["双方向"] = 3,
	};
	head_type = name2num[PI.head_type] or head_type;
end
head_fig = type(PI.head_fig) == "string" and PI.head_fig or head_fig;
head_size = tonumber(PI.head_size) or head_size;
head_width = tonumber(PI.head_width) or head_width;
head_center = tonumber(PI.head_center) or head_center;
head_rot = tonumber(PI.head_rot) or head_rot;
head_pos = tonumber(PI.head_pos) or head_pos;
num_points = tonumber(PI.num_points) or num_points;
if type(PI.path_type) == "string" then
	local name2num = {
		["折れ線"] = 0, ["補間移動"] = 1, ["2次ベジェ曲線"] = 2, ["3次ベジェ曲線"] = 3,
	};
	path_type = name2num[PI.path_type] or path_type;
end
points = type(PI.points) == "table" and PI.points or points;
precision = tonumber(PI.precision) or precision;
antialias = tonumber(PI.antialias) or antialias;
start_pos = tonumber(PI.start_pos) or start_pos;
end_pos = tonumber(PI.end_pos) or end_pos;
if type(PI.end_shape) == "string" then
	local name2num = {
		["円"] = 0, ["四角"] = 1,
	};
	end_shape = name2num[PI.end_shape] or end_shape;
end
dash_pat = type(PI.dash_pat) == "table" and PI.dash_pat or dash_pat;
dash_pos = tonumber(PI.dash_pos) or dash_pos;
rand_period = tonumber(PI.rand_period) or rand_period;
rand_amplify = tonumber(PI.rand_amplify) or rand_amplify;
rand_fix_end = as_bool(PI.rand_fix_end, rand_fix_end);
rand_seed = tonumber(PI.rand_seed) or rand_seed;

-- normalize parameters.
color = math.floor(0.5 + color) % 2 ^ 24;
line = math.max(line, 0);
head_type = math.min(math.max(math.floor(0.5 + head_type), 0), 3);
head_size = math.max(math.floor(0.5 + head_size), 0);
head_width = math.max(head_width / 100, 0);
head_center = head_center / 100;
head_rot = math.pi / 180 * (head_rot % 360);
head_pos = math.min(math.max(head_pos / 100, -1), 1);
num_points = math.max(math.floor(0.5 + num_points), 2);
path_type = math.min(math.max(math.floor(0.5 + path_type), 0), 3);
precision = math.max(precision, 1);
antialias = math.max(antialias, 0);
start_pos = math.min(math.max(start_pos / 100, 0), 1);
end_pos = math.min(math.max(end_pos / 100, 0), 1);
end_shape = math.min(math.max(math.floor(0.5 + end_shape), 0), 1);
rand_period = math.max(rand_period, 4);
rand_amplify = math.max(rand_amplify, 0);
rand_seed = math.min(math.max(math.floor(0.5 + rand_seed), -2 ^ 16), 2 ^ 16 - 1);
if start_pos > end_pos then return end

-- parse/measure the path.
points, num_points = path_s.poll(path_type, points, num_points - 1, false, precision);
if rand_amplify > 0 then
	-- randomize the path.
	if rand_fix_end then
		-- append two extra points near the both ends, so the arrow heads don't shake (if at the ends).
		local x1, y1, x2, y2, x3, y3, x4, y4 = points[1], points[2], points[3], points[4],
			points[2 * num_points - 3], points[2 * num_points - 2],
			points[2 * num_points - 1], points[2 * num_points];
		local dx, dy = x2 - x1, y2 - y1; local l = (dx ^ 2 + dy ^ 2) ^ 0.5;
		x2, y2 = x1 + dx / l, y1 + dy / l;
		dx, dy = x3 - x4, y3 - y4; l = (dx ^ 2 + dy ^ 2) ^ 0.5;
		x3, y3 = x4 + dx / l, y4 + dy / l;

		points, num_points = path_s.randomize(points, num_points,
			rand_period, rand_amplify, 1, rand_seed);

		num_points = num_points + 2;
		table.insert(points, 3, x2);
		table.insert(points, 4, y2);
		table.insert(points, 2 * num_points - 3, x3);
		table.insert(points, 2 * num_points - 2, y3);
	else
		points, num_points = path_s.randomize(points, num_points,
			rand_period, rand_amplify, 0, rand_seed);
	end
end
local L, R, T, B, len = path_s.measure(points, num_points);
local th = line * (end_shape == 1 and 0.5 ^ 0.5 or 0.5) + antialias;
if head_type ~= 0 then
	-- take the arrow heads into account.
	th = math.max(th, head_size / 2 * ((math.abs(head_center) + 1) ^ 2 + head_width ^ 2) ^ 0.5);
end
L, T = math.floor(L - th), math.floor(T - th);
R, B = math.max(math.ceil(R + th), L + 1), math.max(math.ceil(B + th), T + 1);

-- calculate the end points from the calculated length.
local endpt_buff = nil;
if end_shape == 1 then
	endpt_buff = { 0.0, 0.0, 0.0, 0.0; 0.0, 0.0, 0.0, 0.0 };
	local i, j, l = path_s.find_index(-start_pos, points, num_points);
	endpt_buff[1], endpt_buff[2], endpt_buff[3], endpt_buff[4] =
		(1 - j) * points[2 * i - 1] + j * points[2 * i + 1] - L,
		(1 - j) * points[2 * i - 0] + j * points[2 * i + 2] - T,
		points[2 * i + 1] - points[2 * i - 1],
		points[2 * i + 2] - points[2 * i - 0];
	i, j = path_s.find_index(-end_pos, l);
	endpt_buff[5], endpt_buff[6], endpt_buff[7], endpt_buff[8] =
		(1 - j) * points[2 * i - 1] + j * points[2 * i + 1] - L,
		(1 - j) * points[2 * i - 0] + j * points[2 * i + 2] - T,
		points[2 * i + 1] - points[2 * i - 1],
		points[2 * i + 2] - points[2 * i - 0];
end

-- prepare the canvas.
obj.setoption("drawtarget", "tempbuffer", R - L, B - T);
obj.copybuffer("object", "tempbuffer");
local cx, cy = -(L + R) / 2, -(T + B) / 2;

-- draw the path.
path_s.send(points, num_points, -L, -T);
obj.clearbuffer("object", color);
obj.effect("パスマスク(ライン)σ@Path_S", "点リスト", "", "PI",
	([[line=%s,num_points=%d,antialias=%s,start_pos=%s,end_pos=%s,end_shape=%q,dash_pat={%s},dash_pos=%s,pt_buff="tempbuffer",len_buff=%s%s]]):format(
		line, num_points, antialias,
		100 * start_pos, 100 * end_pos, ({ "円", "四角" })[end_shape + 1],
		("%s,"):rep(#dash_pat):format(unpack(dash_pat)), dash_pos,
		len, endpt_buff and (",endpt_buff={%s,%s,%s,%s;%s,%s,%s,%s}"):format(unpack(endpt_buff)) or ""));

-- draw the arrow heads.
if head_type ~= 0 and head_size > 0 and head_width > 0 then
	obj.copybuffer("tempbuffer", "object");
	obj.load("figure", head_fig, color, math.ceil(head_size * math.max(head_width, 1)));
	if obj.w > 0 and obj.h > 0 then
		local function polygon(i, j, rot)
			local X, Y =
				(1 - j) * points[2 * i - 1] + j * points[2 * i + 1],
				(1 - j) * points[2 * i - 0] + j * points[2 * i + 2];
			local A = math.atan2(
				points[2 * i + 2] - points[2 * i - 0],
				points[2 * i + 1] - points[2 * i - 1]);

			-- as to the angle, interpolate with the neighbor secant.
			if j < 0.5 then i = i - 1;
			else i, j = i + 1, 1 - j end
			local dA = 0;
			if 0 < i and i < num_points then
				dA = math.atan2(
					points[2 * i + 2] - points[2 * i - 0],
					points[2 * i + 1] - points[2 * i - 1]);
				dA = (dA - A) / (2 * math.pi);
				dA = ((dA + 0.5) % 1) - 0.5;
				dA = 2 * math.pi * (0.5 - j) * dA;
			end
			A = A + dA + rot;

			local c, s = math.cos(A), math.sin(A);
			X, Y =
				X - head_center * head_size / 2 * s + cx,
				Y + head_center * head_size / 2 * c + cy;
			local w2x, w2y, h2x, h2y = head_size * head_width / 2, 0, 0, head_size / 2;
			w2x, w2y = w2x * c, w2x * s;
			h2x, h2y = h2y *-s, h2y * c;
			return
				{ X - w2x - h2x, Y - w2y - h2y, 0; 0, 0 },
				{ X + w2x - h2x, Y + w2y - h2y, 0; 1, 0 },
				{ X + w2x + h2x, Y + w2y + h2y, 0; 1, 1 },
				{ X - w2x + h2x, Y - w2y + h2y, 0; 0, 1 };
		end

		-- first tip.
		local pos = math.min(math.max(1 + head_pos, 0), 1);
		pos = (1 - pos) * start_pos + pos * end_pos;
		local i, j, l = path_s.find_index(-pos, points, num_points);
		local vts = { polygon(i, j, head_rot + math.pi / 2) };

		if head_type > 1 then
			-- second tip.
			local pos2 = math.min(math.max(head_pos, 0), 1);
			pos2 = (1 - pos2) * start_pos + pos2 * end_pos;
			if pos ~= pos2 then
				i, j = path_s.find_index(-pos2, l);
				vts[5], vts[6], vts[7], vts[8] = polygon(i, j, head_rot
					+ math.pi / 2 * (head_type == 2 and 1 or -1));
			end
		end

		-- "alpha_max" does not seem to work well with obj.drawpoly().
		-- obj.setoption("blend", "alpha_max");
		obj.drawpoly(vts);
		-- obj.setoption("blend", "none");
	end
	obj.copybuffer("object", "tempbuffer");
end

-- adjust the center.
obj.cx, obj.cy = cx, cy;
